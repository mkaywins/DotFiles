'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const coc_utils_1 = require("coc-utils");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const path_1 = __importDefault(require("path"));
const fsac_pkgs = {
    "win-x64": {
        executable: "tools/net6.0/any/fsautocomplete.dll",
        platformPath: /fsautocomplete\..*\.nupkg/
    },
    "linux-x64": {
        executable: "tools/net6.0/any/fsautocomplete.dll",
        platformPath: /fsautocomplete\..*\.nupkg/
    },
    "osx-x64": {
        executable: "tools/net6.0/any/fsautocomplete.dll",
        platformPath: /fsautocomplete\..*\.nupkg/
    },
    "osx-arm64": {
        executable: "tools/net6.0/any/fsautocomplete.dll",
        platformPath: /fsautocomplete\..*\.nupkg/
    },
    "linux-arm64": {
        executable: "tools/net6.0/any/fsautocomplete.dll",
        platformPath: /fsautocomplete\..*\.nupkg/
    },
};
const fsac_repo = {
    kind: "github",
    repo: "fsharp/FsAutoComplete",
    channel: "latest"
};
class FSAC {
    static f1help() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!FSAC.client.started) {
                return null;
            }
            let cursor = yield coc_nvim_1.window.getCursorPosition();
            let doc = yield coc_nvim_1.workspace.document;
            let id = vscode_languageserver_protocol_1.TextDocumentIdentifier.create(doc.uri);
            let uri = yield FSAC.client.sendRequest('fsharp/f1Help', {
                textDocument: id,
                position: cursor
            });
            return JSON.parse(uri.content).Data;
        });
    }
    static activate(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // The server is packaged as a .NET core assembly
            const lsprovider = new coc_utils_1.LanguageServerProvider(context, "FSAC server", fsac_pkgs, fsac_repo);
            const languageServerExe = yield lsprovider.getLanguageServer();
            const config = coc_nvim_1.workspace.getConfiguration('FSharp');
            let verbose = false;
            let statePath = path_1.default.join(coc_nvim_1.workspace.cwd, ".coc-fsharp");
            let serverArgs = [languageServerExe, "--background-service-enabled", "--state-directory", statePath];
            if (config.get("server.trace")) {
                serverArgs.push("--verbose");
                context.logger.info("coc-fsharp: activating verbose logging");
                verbose = true;
            }
            let autoInit = config.get("AutomaticWorkspaceInit", true);
            let dotnet = yield coc_utils_1.DotnetResolver.getDotnetInfo();
            let dotnetRoot = path_1.default.join(dotnet.sdksInstalled[0].path, '..');
            config.update("AutomaticWorkspaceInit", autoInit);
            let env = Object.assign(process.env, { DOTNET_ROOT: dotnetRoot });
            let serverOptions = {
                command: "dotnet",
                args: serverArgs,
                options: { env: env, cwd: coc_nvim_1.workspace.cwd },
                transport: coc_nvim_1.TransportKind.stdio
            };
            let server_outputchannel = coc_nvim_1.window.createOutputChannel("FSAC");
            if (verbose) {
                server_outputchannel.show();
            }
            // Options to control the language client
            let clientOptions = {
                // Register the server for F# documents
                documentSelector: [{ scheme: 'file', language: 'fsharp' }],
                synchronize: {
                    // Synchronize the setting section 'FSharp' to the server
                    configurationSection: 'FSharp',
                    // Notify the server about file changes to F# project files contain in the workspace
                    fileEvents: [
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fsproj'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fs'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fsi'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/*.fsx'),
                        coc_nvim_1.workspace.createFileSystemWatcher('**/project.assets.json')
                    ],
                },
                initializationOptions: {
                    // setting it to true will start Workspace Loading without need to run fsharp/workspacePeek and fsharp/workspaceLoad commands. 
                    // It will always choose top workspace from the found list - all projects in workspace if 0 .sln files are found, .sln file 
                    // if 1 .sln file was found, .sln file with most projects if multiple .sln files were found. It's designed to be used in clients 
                    // that doesn't allow to create custom UI for selecting workspaces.
                    AutomaticWorkspaceInit: autoInit
                },
                outputChannel: server_outputchannel,
            };
            // Create the language client and start the client.
            FSAC.client = new coc_nvim_1.LanguageClient('fsharp', 'FsAutoComplete Language Server', serverOptions, clientOptions);
            FSAC.clientDisposable = FSAC.client.start();
            FSAC.client.onReady().then(() => {
                FSAC.client.onNotification("fsharp/notifyWorkspace", (p) => {
                    let content = JSON.parse(p.content);
                    server_outputchannel.appendLine(`[notifyWorkspace]: ${JSON.stringify(content)}`);
                });
            });
            // Push the disposable to the context's subscriptions so that the 
            // client can be deactivated on extension deactivation
            context.subscriptions.push(FSAC.clientDisposable);
            context.subscriptions.push(coc_nvim_1.commands.registerCommand('fsharp.downloadLanguageServer', () => __awaiter(this, void 0, void 0, function* () {
                if (FSAC.client.started) {
                    yield FSAC.client.stop();
                    FSAC.clientDisposable.dispose();
                    yield (0, coc_utils_1.sleep)(1000);
                }
                yield lsprovider.downloadLanguageServer();
                FSAC.clientDisposable = FSAC.client.start();
                context.subscriptions.push(FSAC.clientDisposable);
            })), coc_nvim_1.commands.registerCommand('fsharp.compile', () => __awaiter(this, void 0, void 0, function* () {
                coc_nvim_1.window.showMessage("Not implemented...", "error");
                //if (client.started) {
                //await client.sendRequest("fsharp/compile");
                //}
            })), coc_nvim_1.commands.registerCommand('fsharp.loadProject', () => __awaiter(this, void 0, void 0, function* () {
                let param = { Directory: coc_nvim_1.workspace.cwd, Deep: 2, ExcludedDirs: [] };
                let p = yield FSAC.client.sendRequest("fsharp/workspacePeek", param);
                server_outputchannel.appendLine(p.content);
                let x = JSON.parse(p.content);
                let entryNames = x.Data.Found.map((v) => {
                    if (v.Type == "solution") {
                        return `Solution: ${path_1.default.basename(v.Data.Path)}`;
                    }
                    else {
                        return `Directory: ${v.Data.Directory} (${v.Data.Fsprojs.length} projects)`;
                    }
                });
                let items = yield (() => __awaiter(this, void 0, void 0, function* () {
                    let selected = x.Data.Found[yield coc_nvim_1.window.showMenuPicker(entryNames, "F# Workspace Peek")];
                    if (selected.Type == "solution") {
                        return [vscode_languageserver_protocol_1.TextDocumentIdentifier.create(coc_nvim_1.Uri.file(selected.Data.Path).toString())];
                    }
                    else {
                        return selected.Data.Fsprojs.map(v => vscode_languageserver_protocol_1.TextDocumentIdentifier.create(coc_nvim_1.Uri.file(v).toString()));
                    }
                }))();
                yield FSAC.client.sendRequest("fsharp/workspaceLoad", { TextDocuments: items });
            })));
        });
    }
}
exports.default = FSAC;
//# sourceMappingURL=fsac.js.map